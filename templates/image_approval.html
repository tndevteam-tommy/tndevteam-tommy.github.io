<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Generation & Approval</title>
    <!--Loads <model-viewer> for modern browsers: -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.5.0/model-viewer.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); max-width: 700px; margin: auto; }
        h1, h2 { color: #333; text-align: center; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], textarea, select { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin-right: 10px; }
        button:hover { background-color: #0056b3; }
        button.reject { background-color: #dc3545; }
        button.reject:hover { background-color: #c82333; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #imagePreviewContainer { margin-top: 20px; text-align: center; }
        #imagePreview { max-width: 100%; max-height: 400px; border-radius: 4px; border: 1px solid #ddd; }
        .hidden { display: none; }
        #statusArea, #resultArea { margin-top: 20px; padding: 10px; border: 1px solid #eee; border-radius: 4px; background-color: #e9ecef; }
        #modelViewerContainer { margin-top: 20px; min-height: 400px; width: 100%; border: 1px solid #ddd; border-radius: 4px; position: relative; /* For positioning controls */ }
        model-viewer { width: 100%; height: 400px; background-color: #f0f0f0; border-radius: 4px; }
        #modelViewerControls { position: absolute; top: 10px; right: 10px; z-index: 10; background-color: rgba(255,255,255,0.8); padding: 5px; border-radius: 4px; }
        #modelViewerControls button { background-color: #6c757d; color: white; padding: 5px 10px; font-size: 12px; margin-left: 5px; border: none; border-radius: 3px; cursor: pointer; }
        #modelViewerControls button:hover { background-color: #5a6268; }
        .spinner {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .form-row { display: flex; gap: 15px; margin-bottom: 15px; }
        .form-row > div { flex: 1; }
        .form-row label { margin-bottom: 5px; }
        .form-row input, .form-row select { width: 100%; box-sizing: border-box; }
        .checkbox-row { display: flex; align-items: center; margin-bottom: 15px; }
        .checkbox-row input[type="checkbox"] { width: auto; margin-right: 10px; margin-bottom: 0; }
        .checkbox-row label { margin-bottom: 0; font-weight: normal; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Image Generation for 3D Model</h1>

        <label for="prompt">Enter your prompt:</label>
        <textarea id="prompt" name="prompt" rows="3" placeholder="e.g., a futuristic sports car"></textarea>

        <div class="form-row">
            <div>
                <label for="model">Model:</label>
                <select id="model" name="model">
                    <option value="flux" selected>flux</option>
                    <option value="kontext">kontext</option>
                    <option value="gptimage">gptimage</option>
                    <!-- Other models will be loaded dynamically -->
                </select>
            </div>
            <div>
                <label for="seed">Seed:</label>
                <input type="number" id="seed" name="seed" value="42" min="0" max="999999">
            </div>
        </div>

        <div class="form-row">
            <div>
                <label for="width">Width (pixels):</label>
                <input type="number" id="width" name="width" value="1024" min="256" max="2048" step="64">
            </div>
            <div>
                <label for="height">Height (pixels):</label>
                <input type="number" id="height" name="height" value="1024" min="256" max="2048" step="64">
            </div>
        </div>

        <div class="checkbox-row">
            <input type="checkbox" id="private" name="private" checked>
            <label for="private">Private (prevent image from appearing in public feed)</label>
        </div>

        <div class="checkbox-row">
            <input type="checkbox" id="enhance" name="enhance">
            <label for="enhance">Enhance prompt using LLM for more detail</label>
        </div>

        <div class="checkbox-row">
            <input type="checkbox" id="transparent" name="transparent" checked>
            <label for="transparent">Transparent background (gptimage model only)</label>
        </div>

        <button id="generateButton">Generate Image</button>
        <div id="generationSpinner" class="spinner hidden"></div>

        <hr style="margin: 30px 0;">

        <h2>Or Upload Your Own Image for 3D Model</h2>
        <div id="dropZone" style="border: 2px dashed #007bff; border-radius: 5px; padding: 30px; text-align: center; margin-bottom: 15px; background-color: #f8f9fa;">
            <p>Drag & Drop an image here, or click to select file</p>
            <input type="file" id="fileInput" accept="image/png, image/jpeg, image/jpg" style="display: none;">
            <img id="droppedImagePreview" src="#" alt="Dropped Image Preview" class="hidden" style="max-width: 100%; max-height: 200px; margin-top: 10px; border-radius: 4px; border: 1px solid #ddd;">
        </div>
        <button id="uploadAndProcessButton" class="hidden">Create 3D Model from Uploaded Image</button>
        <div id="uploadSpinner" class="spinner hidden"></div>
        
        <div id="approvalSection" class="hidden">
            <h2>Review Generated Image</h2>
            <div id="imagePreviewContainer">
                <img id="imagePreview" src="#" alt="Generated Image" />
            </div>
            <div style="text-align: center; margin-top: 15px;">
                <button id="approveButton">Approve & Create 3D Model</button>
                <button id="rejectButton" class="reject">Reject & Try Again</button>
            </div>
        </div>

        <div id="processingSection" class="hidden">
            <h2>3D Model Processing Status</h2>
            <div id="modelSpinner" class="spinner"></div>
            <div id="statusArea">Waiting for server...</div>
            <div id="resultArea" class="hidden">
                <h3>Results:</h3>
                <ul id="resultList"></ul>
                <div id="modelViewerContainer" class="hidden">
                    <p style="text-align:center; margin-bottom:10px;">3D Model Preview:</p>
                    <!-- model-viewer will be inserted here by JavaScript -->
                    <div id="modelViewerControls" class="hidden">
                        <button id="bgLightButton">Light BG</button>
                        <button id="bgDarkButton">Dark BG</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const promptInput = document.getElementById('prompt');
        const modelSelect = document.getElementById('model');
        const seedInput = document.getElementById('seed');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        const privateCheckbox = document.getElementById('private');
        const enhanceCheckbox = document.getElementById('enhance');
        const transparentCheckbox = document.getElementById('transparent');
        const generateButton = document.getElementById('generateButton');
        const generationSpinner = document.getElementById('generationSpinner');
        
        const approvalSection = document.getElementById('approvalSection');
        const imagePreview = document.getElementById('imagePreview');
        const approveButton = document.getElementById('approveButton');
        const rejectButton = document.getElementById('rejectButton');

        const processingSection = document.getElementById('processingSection');
        const modelSpinner = document.getElementById('modelSpinner');
        const statusArea = document.getElementById('statusArea');
        const resultArea = document.getElementById('resultArea');
        const resultList = document.getElementById('resultList');
        const modelViewerContainer = document.getElementById('modelViewerContainer');

        // New elements for drag and drop
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const droppedImagePreview = document.getElementById('droppedImagePreview');
        const uploadAndProcessButton = document.getElementById('uploadAndProcessButton');
        const uploadSpinner = document.getElementById('uploadSpinner');

        // Model viewer background controls
        const modelViewerControls = document.getElementById('modelViewerControls');
        const bgLightButton = document.getElementById('bgLightButton');
        const bgDarkButton = document.getElementById('bgDarkButton');

        let currentImageFilename = null;
        let currentRequestId = null;
        let pollInterval = null;

        let currentModifiedImageFilename = null;
        let currentModifiedImageUrl = null;

        // Load available models from Pollinations.ai API
        async function loadModels() {
            try {
                const response = await fetch('https://text.pollinations.ai/models');
                if (!response.ok) {
                    console.warn('Failed to load models from Pollinations.ai API');
                    return;
                }
                const models = await response.json();
                // Only add new options if not already present
                const existingValues = Array.from(modelSelect.options).map(opt => opt.value);
                models.forEach(model => {
                    if (!existingValues.includes(model)) {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        modelSelect.appendChild(option);
                    }
                });
                console.log(`Loaded ${models.length} image models from Pollinations.ai API`);
            } catch (error) {
                console.error('Error loading models:', error);
            }
        }

        function resetUI() {
            promptInput.value = '';
            approvalSection.classList.add('hidden');
            processingSection.classList.add('hidden');
            resultArea.classList.add('hidden');
            resultList.innerHTML = '';
            modelViewerContainer.classList.add('hidden');
            modelViewerContainer.innerHTML = '<p style="text-align:center; margin-bottom:10px;">3D Model Preview:</p><div id="modelViewerControls" class="hidden"><button id="bgLightButton">Light BG</button><button id="bgDarkButton">Dark BG</button></div>';
            statusArea.textContent = 'Waiting for server...';
            currentImageFilename = null;
            currentRequestId = null;
            if (pollInterval) clearInterval(pollInterval);
            generateButton.disabled = false;
            generationSpinner.classList.add('hidden');
            modelSpinner.classList.add('hidden');
            uploadSpinner.classList.add('hidden'); // Hide upload spinner on reset
            droppedImagePreview.classList.add('hidden'); // Hide dropped image preview
            droppedImagePreview.src = '#';
            uploadAndProcessButton.classList.add('hidden'); // Hide upload button
            fileInput.value = ''; // Reset file input
            hideModifyButton(); // Hide modify button on reset
        }

        generateButton.addEventListener('click', async () => {
            const promptText = promptInput.value.trim();
            if (!promptText) {
                alert('Please enter a prompt.');
                return;
            }

            generateButton.disabled = true;
            generationSpinner.classList.remove('hidden');
            approvalSection.classList.add('hidden');
            processingSection.classList.add('hidden');

            try {
                const requestData = {
                    prompt: promptText,
                    model: modelSelect.value,
                    seed: parseInt(seedInput.value),
                    width: parseInt(widthInput.value),
                    height: parseInt(heightInput.value),
                    private: privateCheckbox.checked,
                    enhance: enhanceCheckbox.checked,
                    transparent: transparentCheckbox.checked
                };

                const response = await fetch('/generate_for_approval', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
                }

                const data = await response.json();
                if (data.status === 'success') {
                    imagePreview.src = data.image_url + '?t=' + new Date().getTime(); // Cache buster
                    currentImageFilename = data.image_filename;
                    approvalSection.classList.remove('hidden');
                    showModifyButton(); // Show modify button after generation
                } else {
                    throw new Error(data.message || 'Image generation failed.');
                }
            } catch (error) {
                console.error('Error generating image:', error);
                statusArea.textContent = `Error generating image: ${error.message}`;
                alert(`Error generating image: ${error.message}`);
            } finally {
                generateButton.disabled = false;
                generationSpinner.classList.add('hidden');
            }
        });

        approveButton.addEventListener('click', async () => {
            if (!currentImageFilename) {
                alert('No image to approve.');
                return;
            }

            approveButton.disabled = true;
            rejectButton.disabled = true;
            processingSection.classList.remove('hidden');
            modelSpinner.classList.remove('hidden');
            statusArea.textContent = 'Submitting image for 3D model processing...';

            try {
                const response = await fetch('/process_approved_image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_filename: currentImageFilename })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
                }

                const data = await response.json();
                if (data.status === 'queued' && data.request_id) {
                    currentRequestId = data.request_id;
                    statusArea.textContent = `Generating 3D model (Request ID: ${currentRequestId}). Please wait...`;
                    pollInterval = setInterval(checkStatus, 10000); // Poll every 10 seconds
                } else {
                    throw new Error(data.message || 'Failed to queue image for processing.');
                }
            } catch (error) {
                console.error('Error processing approved image:', error);
                statusArea.textContent = `Error: ${error.message}`;
                alert(`Error: ${error.message}`);
                approveButton.disabled = false;
                rejectButton.disabled = false;
                modelSpinner.classList.add('hidden');
            }
        });

        rejectButton.addEventListener('click', () => {
            resetUI();
            promptInput.focus();
        });

        async function checkStatus() {
            if (!currentRequestId) return;

            try {
                const response = await fetch(`/status/${currentRequestId}`);
                if (!response.ok) {
                    statusArea.textContent = 'Error checking status. Will retry...';
                    console.error('Status check failed:', response.status);
                    return; // Keep polling
                }

                const data = await response.json();
                statusArea.textContent = `Status: ${data.status}`;

                if (data.status === 'completed') {
                    clearInterval(pollInterval);
                    modelSpinner.classList.add('hidden');
                    approveButton.disabled = false; // Re-enable for new generation
                    rejectButton.disabled = false;  // Re-enable
                    
                    resultArea.classList.remove('hidden');
                    resultList.innerHTML = ''; // Clear previous results
                    modelViewerContainer.classList.add('hidden');
                    modelViewerContainer.innerHTML = '<p style="text-align:center; margin-bottom:10px;">3D Model Preview:</p><div id="modelViewerControls" class="hidden"><button id="bgLightButton">Light BG</button><button id="bgDarkButton">Dark BG</button></div>';
                    const initialModelViewerControls = document.getElementById('modelViewerControls'); // Controls associated with main page structure
                    if(initialModelViewerControls) initialModelViewerControls.classList.add('hidden');

                    // Check for model_urls and display the first one
                    if (data.model_urls && data.model_urls.length > 0) {
                        const modelUrl = data.model_urls[0]; // Display the first model
                        const mv = document.createElement('model-viewer');
                        mv.setAttribute('src', modelUrl);
                        mv.setAttribute('alt', '3D model preview');
                        mv.setAttribute('auto-rotate', '');
                        mv.setAttribute('camera-controls', '');
                        mv.setAttribute('shadow-intensity', '1');
                        mv.setAttribute('style', 'width: 100%; height: 400px; background-color: #f8f9fa; border-radius: 4px;');
                        
                        // Insert mv after the <p> and before the controls div
                        modelViewerContainer.insertBefore(mv, initialModelViewerControls);

                        modelViewerContainer.classList.remove('hidden');
                        initialModelViewerControls.classList.remove('hidden');

                        // Event listeners for background controls for the CURRENT model viewer
                        const localBgLightButton = modelViewerContainer.querySelector('#bgLightButton');
                        const localBgDarkButton = modelViewerContainer.querySelector('#bgDarkButton');
                        localBgLightButton.onclick = () => mv.style.backgroundColor = '#f8f9fa';
                        localBgDarkButton.onclick = () => mv.style.backgroundColor = '#343a40';

                        // Also, list all model URLs as text for reference
                        data.model_urls.forEach(url => {
                            const listItem = document.createElement('li');
                            const filename = url.split('/').pop();
                            const link = document.createElement('a');
                            link.href = url;
                            link.textContent = `Download ${filename}`;
                            link.setAttribute('download', filename);
                            listItem.appendChild(link);
                            resultList.appendChild(listItem);
                        });
                    } else if (data.results && data.results.length > 0) { 
                        // Fallback for old results format or non-GLB results if any (though status endpoint was changed)
                        data.results.forEach(resultPath => {
                            const listItem = document.createElement('li');
                            const filename = resultPath.split('\\').pop().split('/').pop();
                            listItem.textContent = `File created: ${filename} (Full path: ${resultPath})`;
                            resultList.appendChild(listItem);
                        });
                    } else {
                        resultList.innerHTML = '<li>No model files were generated or an error occurred.</li>';
                    }
                    statusArea.textContent = '3D Model processing complete!';
                } else if (data.status === 'pending') {
                    // Continue polling
                } else { // Error or unknown status
                    clearInterval(pollInterval);
                    statusArea.textContent = `Processing ended with status: ${data.status}. Check server logs.`;
                    modelSpinner.classList.add('hidden');
                }
            } catch (error) {
                console.error('Error polling status:', error);
                statusArea.textContent = 'Error polling status. Will retry...';
            }
        }
        
        // --- Drag and Drop & File Upload Logic ---
        dropZone.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser from opening file
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        dropZone.addEventListener('dragenter', () => dropZone.style.borderColor = '#28a745'); // Green border on enter
        dropZone.addEventListener('dragleave', () => dropZone.style.borderColor = '#007bff'); // Reset border

        dropZone.addEventListener('drop', (e) => {
            dropZone.style.borderColor = '#007bff'; // Reset border
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        let selectedFileForUpload = null;

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file (PNG, JPG).');
                return;
            }
            selectedFileForUpload = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                droppedImagePreview.src = e.target.result;
                droppedImagePreview.classList.remove('hidden');
                uploadAndProcessButton.classList.remove('hidden');
                
                // Hide other sections if they were open
                approvalSection.classList.add('hidden');
                processingSection.classList.add('hidden');
            }
            reader.readAsDataURL(file);
        }

        uploadAndProcessButton.addEventListener('click', async () => {
            if (!selectedFileForUpload) {
                alert('No file selected for upload.');
                return;
            }

            uploadAndProcessButton.disabled = true;
            uploadSpinner.classList.remove('hidden');
            processingSection.classList.remove('hidden'); // Show processing section
            modelSpinner.classList.remove('hidden');
            statusArea.textContent = 'Uploading image and preparing for 3D model generation...';
            resultArea.classList.add('hidden');
            resultList.innerHTML = '';
            modelViewerContainer.classList.add('hidden');
            modelViewerContainer.innerHTML = '<p style="text-align:center; margin-bottom:10px;">3D Model Preview:</p><div id="modelViewerControls" class="hidden"><button id="bgLightButton">Light BG</button><button id="bgDarkButton">Dark BG</button></div>';
            const initialModelViewerControls = document.getElementById('modelViewerControls'); // Controls associated with main page structure
            if(initialModelViewerControls) initialModelViewerControls.classList.add('hidden');

            const formData = new FormData();
            formData.append('file', selectedFileForUpload);
            // Add default SF3D parameters. These could be configurable in the UI later.
            formData.append('foreground_ratio', '0.85');
            formData.append('texture_resolution', '1024');
            formData.append('remesh_option', 'triangle');
            formData.append('target_vertex_count', '-1');
            formData.append('batch_size', '1');

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
                }

                const data = await response.json();
                if (data.status === 'success' && data.request_id) {
                    currentRequestId = data.request_id; // Reusing currentRequestId for polling
                    statusArea.textContent = `Image uploaded. Generating 3D model (Request ID: ${currentRequestId}). Please wait...`;
                    pollInterval = setInterval(checkStatus, 10000); // Poll every 10 seconds
                } else {
                    throw new Error(data.message || 'Failed to queue uploaded image for processing.');
                }
            } catch (error) {
                console.error('Error uploading and processing image:', error);
                statusArea.textContent = `Error: ${error.message}`;
                alert(`Error: ${error.message}`);
                modelSpinner.classList.add('hidden');
            } finally {
                uploadAndProcessButton.disabled = false;
                uploadSpinner.classList.add('hidden');
            }
        });

        // Add a Modify button to the approval section
        const modifyButton = document.createElement('button');
        modifyButton.id = 'modifyButton';
        modifyButton.textContent = 'Modify Image';
        modifyButton.style.marginLeft = '10px';
        modifyButton.classList.add('hidden');

        // Insert modifyButton after approveButton
        approveButton.parentNode.insertBefore(modifyButton, approveButton.nextSibling);

        function showModifyButton() {
            modifyButton.classList.remove('hidden');
        }
        function hideModifyButton() {
            modifyButton.classList.add('hidden');
        }

        // Show modify button after image is generated or uploaded
        // After imagePreview.src is set and approvalSection is shown:
        approveButton.addEventListener('click', () => {
            if (imagePreview.src.includes('?t=')) { // Check if it's a cached URL
                showModifyButton();
            }
        });

        // Modify button click handler
        modifyButton.addEventListener('click', async () => {
            let newPrompt = prompt('Enter a new prompt for modification:', promptInput.value);
            if (!newPrompt) return;
            modifyButton.disabled = true;
            statusArea.textContent = 'Modifying image...';
            try {
                const requestData = {
                    prompt: newPrompt,
                    image_url: imagePreview.src.split('?')[0]
                };
                const response = await fetch('/modify_image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                if (data.status === 'success') {
                    imagePreview.src = data.image_url + '?t=' + new Date().getTime();
                    currentModifiedImageFilename = data.image_filename;
                    currentModifiedImageUrl = data.image_url;
                    approvalSection.classList.remove('hidden');
                    showModifyButton();
                } else {
                    throw new Error(data.message || 'Image modification failed.');
                }
            } catch (error) {
                console.error('Error modifying image:', error);
                statusArea.textContent = `Error modifying image: ${error.message}`;
                alert(`Error modifying image: ${error.message}`);
            } finally {
                modifyButton.disabled = false;
            }
        });

        // Load models on page load
        loadModels();

        // Initial UI state
        resetUI();

    </script>
</body>
</html> 